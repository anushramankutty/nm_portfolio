{"ast":null,"code":"/** @license React v16.6.0\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n\n    /* eslint-disable no-var */\n\n    // TODO: Use symbols?\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var IdlePriority = 4;\n\n    // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n    var maxSigned31BitInt = 1073741823;\n\n    // Times out immediately\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1;\n    // Eventually times out\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    // Never times out\n    var IDLE_PRIORITY = maxSigned31BitInt;\n\n    // Callbacks are stored as a circular, doubly linked list.\n    var firstCallbackNode = null;\n    var currentPriorityLevel = NormalPriority;\n    var currentEventStartTime = -1;\n    var currentExpirationTime = -1;\n\n    // This is set when a callback is being executed, to prevent re-entrancy.\n    var isExecutingCallback = false;\n    var isHostCallbackScheduled = false;\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    var timeRemaining;\n    if (hasNativePerformanceNow) {\n      timeRemaining = function () {\n        if (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime) {\n          // A higher priority callback was scheduled. Yield so we can switch to\n          // working on that.\n          return 0;\n        }\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        var remaining = getFrameDeadline() - performance.now();\n        return remaining > 0 ? remaining : 0;\n      };\n    } else {\n      timeRemaining = function () {\n        // Fallback to Date.now()\n        if (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime) {\n          return 0;\n        }\n        var remaining = getFrameDeadline() - Date.now();\n        return remaining > 0 ? remaining : 0;\n      };\n    }\n    var deadlineObject = {\n      timeRemaining: timeRemaining,\n      didTimeout: false\n    };\n    function ensureHostCallbackIsScheduled() {\n      if (isExecutingCallback) {\n        // Don't schedule work yet; wait until the next time we yield.\n        return;\n      }\n      // Schedule the host callback using the earliest expiration in the list.\n      var expirationTime = firstCallbackNode.expirationTime;\n      if (!isHostCallbackScheduled) {\n        isHostCallbackScheduled = true;\n      } else {\n        // Cancel the existing host callback.\n        cancelHostCallback();\n      }\n      requestHostCallback(flushWork, expirationTime);\n    }\n    function flushFirstCallback() {\n      var flushedNode = firstCallbackNode;\n\n      // Remove the node from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n      var next = firstCallbackNode.next;\n      if (firstCallbackNode === next) {\n        // This is the last callback in the list.\n        firstCallbackNode = null;\n        next = null;\n      } else {\n        var lastCallbackNode = firstCallbackNode.previous;\n        firstCallbackNode = lastCallbackNode.next = next;\n        next.previous = lastCallbackNode;\n      }\n      flushedNode.next = flushedNode.previous = null;\n\n      // Now it's safe to call the callback.\n      var callback = flushedNode.callback;\n      var expirationTime = flushedNode.expirationTime;\n      var priorityLevel = flushedNode.priorityLevel;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousExpirationTime = currentExpirationTime;\n      currentPriorityLevel = priorityLevel;\n      currentExpirationTime = expirationTime;\n      var continuationCallback;\n      try {\n        continuationCallback = callback(deadlineObject);\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentExpirationTime = previousExpirationTime;\n      }\n\n      // A callback may return a continuation. The continuation should be scheduled\n      // with the same priority and expiration as the just-finished callback.\n      if (typeof continuationCallback === 'function') {\n        var continuationNode = {\n          callback: continuationCallback,\n          priorityLevel: priorityLevel,\n          expirationTime: expirationTime,\n          next: null,\n          previous: null\n        };\n\n        // Insert the new callback into the list, sorted by its expiration. This is\n        // almost the same as the code in `scheduleCallback`, except the callback\n        // is inserted into the list *before* callbacks of equal expiration instead\n        // of after.\n        if (firstCallbackNode === null) {\n          // This is the first callback in the list.\n          firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n        } else {\n          var nextAfterContinuation = null;\n          var node = firstCallbackNode;\n          do {\n            if (node.expirationTime >= expirationTime) {\n              // This callback expires at or after the continuation. We will insert\n              // the continuation *before* this callback.\n              nextAfterContinuation = node;\n              break;\n            }\n            node = node.next;\n          } while (node !== firstCallbackNode);\n          if (nextAfterContinuation === null) {\n            // No equal or lower priority callback was found, which means the new\n            // callback is the lowest priority callback in the list.\n            nextAfterContinuation = firstCallbackNode;\n          } else if (nextAfterContinuation === firstCallbackNode) {\n            // The new callback is the highest priority callback in the list.\n            firstCallbackNode = continuationNode;\n            ensureHostCallbackIsScheduled();\n          }\n          var previous = nextAfterContinuation.previous;\n          previous.next = nextAfterContinuation.previous = continuationNode;\n          continuationNode.next = nextAfterContinuation;\n          continuationNode.previous = previous;\n        }\n      }\n    }\n    function flushImmediateWork() {\n      if (\n      // Confirm we've exited the outer most event handler\n      currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n        isExecutingCallback = true;\n        deadlineObject.didTimeout = true;\n        try {\n          do {\n            flushFirstCallback();\n          } while (\n          // Keep flushing until there are no more immediate callbacks\n          firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n        } finally {\n          isExecutingCallback = false;\n          if (firstCallbackNode !== null) {\n            // There's still work remaining. Request another callback.\n            ensureHostCallbackIsScheduled();\n          } else {\n            isHostCallbackScheduled = false;\n          }\n        }\n      }\n    }\n    function flushWork(didTimeout) {\n      isExecutingCallback = true;\n      deadlineObject.didTimeout = didTimeout;\n      try {\n        if (didTimeout) {\n          // Flush all the expired callbacks without yielding.\n          while (firstCallbackNode !== null) {\n            // Read the current time. Flush all the callbacks that expire at or\n            // earlier than that time. Then read the current time again and repeat.\n            // This optimizes for as few performance.now calls as possible.\n            var currentTime = exports.unstable_now();\n            if (firstCallbackNode.expirationTime <= currentTime) {\n              do {\n                flushFirstCallback();\n              } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime);\n              continue;\n            }\n            break;\n          }\n        } else {\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstCallbackNode !== null) {\n            do {\n              flushFirstCallback();\n            } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n          }\n        }\n      } finally {\n        isExecutingCallback = false;\n        if (firstCallbackNode !== null) {\n          // There's still work remaining. Request another callback.\n          ensureHostCallbackIsScheduled();\n        } else {\n          isHostCallbackScheduled = false;\n        }\n        // Before exiting, flush all the immediate work that was scheduled.\n        flushImmediateWork();\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousEventStartTime = currentEventStartTime;\n      currentPriorityLevel = priorityLevel;\n      currentEventStartTime = exports.unstable_now();\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentEventStartTime = previousEventStartTime;\n\n        // Before exiting, flush all the immediate work that was scheduled.\n        flushImmediateWork();\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        var previousEventStartTime = currentEventStartTime;\n        currentPriorityLevel = parentPriorityLevel;\n        currentEventStartTime = exports.unstable_now();\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n          currentEventStartTime = previousEventStartTime;\n          flushImmediateWork();\n        }\n      };\n    }\n    function unstable_scheduleCallback(callback, deprecated_options) {\n      var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n      var expirationTime;\n      if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n        // FIXME: Remove this branch once we lift expiration times out of React.\n        expirationTime = startTime + deprecated_options.timeout;\n      } else {\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n          case UserBlockingPriority:\n            expirationTime = startTime + USER_BLOCKING_PRIORITY;\n            break;\n          case IdlePriority:\n            expirationTime = startTime + IDLE_PRIORITY;\n            break;\n          case NormalPriority:\n          default:\n            expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n        }\n      }\n      var newNode = {\n        callback: callback,\n        priorityLevel: currentPriorityLevel,\n        expirationTime: expirationTime,\n        next: null,\n        previous: null\n      };\n\n      // Insert the new callback into the list, ordered first by expiration, then\n      // by insertion. So the new callback is inserted any other callback with\n      // equal expiration.\n      if (firstCallbackNode === null) {\n        // This is the first callback in the list.\n        firstCallbackNode = newNode.next = newNode.previous = newNode;\n        ensureHostCallbackIsScheduled();\n      } else {\n        var next = null;\n        var node = firstCallbackNode;\n        do {\n          if (node.expirationTime > expirationTime) {\n            // The new callback expires before this one.\n            next = node;\n            break;\n          }\n          node = node.next;\n        } while (node !== firstCallbackNode);\n        if (next === null) {\n          // No callback with a later expiration was found, which means the new\n          // callback has the latest expiration in the list.\n          next = firstCallbackNode;\n        } else if (next === firstCallbackNode) {\n          // The new callback has the earliest expiration in the entire list.\n          firstCallbackNode = newNode;\n          ensureHostCallbackIsScheduled();\n        }\n        var previous = next.previous;\n        previous.next = next.previous = newNode;\n        newNode.next = next;\n        newNode.previous = previous;\n      }\n      return newNode;\n    }\n    function unstable_cancelCallback(callbackNode) {\n      var next = callbackNode.next;\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n      if (next === callbackNode) {\n        // This is the only scheduled callback. Clear the list.\n        firstCallbackNode = null;\n      } else {\n        // Remove the callback from its position in the list.\n        if (callbackNode === firstCallbackNode) {\n          firstCallbackNode = next;\n        }\n        var previous = callbackNode.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      callbackNode.next = callbackNode.previous = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n\n    // The remaining code is essentially a polyfill for requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated. We want to be using a\n    // consistent implementation.\n    var localDate = Date;\n\n    // This initialization code may run even on server environments if a component\n    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n    // have setTimeout or clearTimeout. However, we always expect them to be defined\n    // on the client. https://github.com/facebook/react/pull/13088\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n    // We don't expect either of these to necessarily be defined, but we will error\n    // later if they are missing on the client.\n    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n    // requestAnimationFrame does not run when the tab is in the background. If\n    // we're backgrounded we prefer for that work to happen so that the page\n    // continues to load in the background. So we also schedule a 'setTimeout' as\n    // a fallback.\n    // TODO: Need a better heuristic for backgrounded work.\n    var ANIMATION_FRAME_TIMEOUT = 100;\n    var rAFID;\n    var rAFTimeoutID;\n    var requestAnimationFrameWithTimeout = function (callback) {\n      // schedule rAF and also a setTimeout\n      rAFID = localRequestAnimationFrame(function (timestamp) {\n        // cancel the setTimeout\n        localClearTimeout(rAFTimeoutID);\n        callback(timestamp);\n      });\n      rAFTimeoutID = localSetTimeout(function () {\n        // cancel the requestAnimationFrame\n        localCancelAnimationFrame(rAFID);\n        callback(exports.unstable_now());\n      }, ANIMATION_FRAME_TIMEOUT);\n    };\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n      exports.unstable_now = function () {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function () {\n        return localDate.now();\n      };\n    }\n    var requestHostCallback;\n    var cancelHostCallback;\n    var getFrameDeadline;\n    if (typeof window !== 'undefined' && window._schedMock) {\n      // Dynamic injection, only for testing purposes.\n      var impl = window._schedMock;\n      requestHostCallback = impl[0];\n      cancelHostCallback = impl[1];\n      getFrameDeadline = impl[2];\n    } else if (\n    // If Scheduler runs in a non-DOM environment, it falls back to a naive\n    // implementation using setTimeout.\n    typeof window === 'undefined' ||\n    // \"addEventListener\" might not be available on the window object\n    // if this is a mocked \"window\" object. So we need to validate that too.\n    typeof window.addEventListener !== 'function') {\n      var _callback = null;\n      var _currentTime = -1;\n      var _flushCallback = function (didTimeout, ms) {\n        if (_callback !== null) {\n          var cb = _callback;\n          _callback = null;\n          try {\n            _currentTime = ms;\n            cb(didTimeout);\n          } finally {\n            _currentTime = -1;\n          }\n        }\n      };\n      requestHostCallback = function (cb, ms) {\n        if (_currentTime !== -1) {\n          // Protect against re-entrancy.\n          setTimeout(requestHostCallback, 0, cb, ms);\n        } else {\n          _callback = cb;\n          setTimeout(_flushCallback, ms, true, ms);\n          setTimeout(_flushCallback, maxSigned31BitInt, false, maxSigned31BitInt);\n        }\n      };\n      cancelHostCallback = function () {\n        _callback = null;\n      };\n      getFrameDeadline = function () {\n        return Infinity;\n      };\n      exports.unstable_now = function () {\n        return _currentTime === -1 ? 0 : _currentTime;\n      };\n    } else {\n      if (typeof console !== 'undefined') {\n        // TODO: Remove fb.me link\n        if (typeof localRequestAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n        if (typeof localCancelAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n      }\n      var scheduledHostCallback = null;\n      var isMessageEventScheduled = false;\n      var timeoutTime = -1;\n      var isAnimationFrameScheduled = false;\n      var isFlushingHostCallback = false;\n      var frameDeadline = 0;\n      // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n      getFrameDeadline = function () {\n        return frameDeadline;\n      };\n\n      // We use the postMessage trick to defer idle work until after the repaint.\n      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n      var idleTick = function (event) {\n        if (event.source !== window || event.data !== messageKey) {\n          return;\n        }\n        isMessageEventScheduled = false;\n        var prevScheduledCallback = scheduledHostCallback;\n        var prevTimeoutTime = timeoutTime;\n        scheduledHostCallback = null;\n        timeoutTime = -1;\n        var currentTime = exports.unstable_now();\n        var didTimeout = false;\n        if (frameDeadline - currentTime <= 0) {\n          // There's no time left in this idle period. Check if the callback has\n          // a timeout and whether it's been exceeded.\n          if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n            // Exceeded the timeout. Invoke the callback even though there's no\n            // time left.\n            didTimeout = true;\n          } else {\n            // No timeout.\n            if (!isAnimationFrameScheduled) {\n              // Schedule another animation callback so we retry later.\n              isAnimationFrameScheduled = true;\n              requestAnimationFrameWithTimeout(animationTick);\n            }\n            // Exit without invoking the callback.\n            scheduledHostCallback = prevScheduledCallback;\n            timeoutTime = prevTimeoutTime;\n            return;\n          }\n        }\n        if (prevScheduledCallback !== null) {\n          isFlushingHostCallback = true;\n          try {\n            prevScheduledCallback(didTimeout);\n          } finally {\n            isFlushingHostCallback = false;\n          }\n        }\n      };\n      // Assumes that we have addEventListener in this environment. Might need\n      // something better for old IE.\n      window.addEventListener('message', idleTick, false);\n      var animationTick = function (rafTime) {\n        if (scheduledHostCallback !== null) {\n          // Eagerly schedule the next animation callback at the beginning of the\n          // frame. If the scheduler queue is not empty at the end of the frame, it\n          // will continue flushing inside that callback. If the queue *is* empty,\n          // then it will exit immediately. Posting the callback at the start of the\n          // frame ensures it's fired within the earliest possible frame. If we\n          // waited until the end of the frame to post the callback, we risk the\n          // browser skipping a frame and not firing the callback until the frame\n          // after that.\n          requestAnimationFrameWithTimeout(animationTick);\n        } else {\n          // No pending work. Exit.\n          isAnimationFrameScheduled = false;\n          return;\n        }\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If the calculated frame time gets lower than 8, it is probably a bug.\n            nextFrameTime = 8;\n          }\n          // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n        frameDeadline = rafTime + activeFrameTime;\n        if (!isMessageEventScheduled) {\n          isMessageEventScheduled = true;\n          window.postMessage(messageKey, '*');\n        }\n      };\n      requestHostCallback = function (callback, absoluteTimeout) {\n        scheduledHostCallback = callback;\n        timeoutTime = absoluteTimeout;\n        if (isFlushingHostCallback || absoluteTimeout < 0) {\n          // Don't wait for the next frame. Continue working ASAP, in a new event.\n          window.postMessage(messageKey, '*');\n        } else if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n      };\n      cancelHostCallback = function () {\n        scheduledHostCallback = null;\n        isMessageEventScheduled = false;\n        timeoutTime = -1;\n      };\n    }\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","ImmediatePriority","UserBlockingPriority","NormalPriority","IdlePriority","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","NORMAL_PRIORITY_TIMEOUT","IDLE_PRIORITY","firstCallbackNode","currentPriorityLevel","currentEventStartTime","currentExpirationTime","isExecutingCallback","isHostCallbackScheduled","hasNativePerformanceNow","performance","now","timeRemaining","expirationTime","remaining","getFrameDeadline","Date","deadlineObject","didTimeout","ensureHostCallbackIsScheduled","cancelHostCallback","requestHostCallback","flushWork","flushFirstCallback","flushedNode","next","lastCallbackNode","previous","callback","priorityLevel","previousPriorityLevel","previousExpirationTime","continuationCallback","continuationNode","nextAfterContinuation","node","flushImmediateWork","currentTime","unstable_now","unstable_runWithPriority","eventHandler","previousEventStartTime","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_scheduleCallback","deprecated_options","startTime","timeout","newNode","unstable_cancelCallback","callbackNode","unstable_getCurrentPriorityLevel","localDate","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","ANIMATION_FRAME_TIMEOUT","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","Performance","window","_schedMock","impl","addEventListener","_callback","_currentTime","_flushCallback","ms","cb","Infinity","console","error","scheduledHostCallback","isMessageEventScheduled","timeoutTime","isAnimationFrameScheduled","isFlushingHostCallback","frameDeadline","previousFrameTime","activeFrameTime","messageKey","Math","random","toString","slice","idleTick","event","source","data","prevScheduledCallback","prevTimeoutTime","animationTick","rafTime","nextFrameTime","postMessage","absoluteTimeout","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority"],"sources":["C:/Users/lovel/Desktop/Hari JS/node_modules/scheduler/cjs/scheduler.development.js"],"sourcesContent":["/** @license React v16.6.0\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar IdlePriority = 4;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar currentPriorityLevel = NormalPriority;\nvar currentEventStartTime = -1;\nvar currentExpirationTime = -1;\n\n// This is set when a callback is being executed, to prevent re-entrancy.\nvar isExecutingCallback = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar timeRemaining;\nif (hasNativePerformanceNow) {\n  timeRemaining = function () {\n    if (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime) {\n      // A higher priority callback was scheduled. Yield so we can switch to\n      // working on that.\n      return 0;\n    }\n    // We assume that if we have a performance timer that the rAF callback\n    // gets a performance timer value. Not sure if this is always true.\n    var remaining = getFrameDeadline() - performance.now();\n    return remaining > 0 ? remaining : 0;\n  };\n} else {\n  timeRemaining = function () {\n    // Fallback to Date.now()\n    if (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime) {\n      return 0;\n    }\n    var remaining = getFrameDeadline() - Date.now();\n    return remaining > 0 ? remaining : 0;\n  };\n}\n\nvar deadlineObject = {\n  timeRemaining: timeRemaining,\n  didTimeout: false\n};\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isExecutingCallback) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest expiration in the list.\n  var expirationTime = firstCallbackNode.expirationTime;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelHostCallback();\n  }\n  requestHostCallback(flushWork, expirationTime);\n}\n\nfunction flushFirstCallback() {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var lastCallbackNode = firstCallbackNode.previous;\n    firstCallbackNode = lastCallbackNode.next = next;\n    next.previous = lastCallbackNode;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  var expirationTime = flushedNode.expirationTime;\n  var priorityLevel = flushedNode.priorityLevel;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousExpirationTime = currentExpirationTime;\n  currentPriorityLevel = priorityLevel;\n  currentExpirationTime = expirationTime;\n  var continuationCallback;\n  try {\n    continuationCallback = callback(deadlineObject);\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentExpirationTime = previousExpirationTime;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var continuationNode = {\n      callback: continuationCallback,\n      priorityLevel: priorityLevel,\n      expirationTime: expirationTime,\n      next: null,\n      previous: null\n    };\n\n    // Insert the new callback into the list, sorted by its expiration. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal expiration instead\n    // of after.\n    if (firstCallbackNode === null) {\n      // This is the first callback in the list.\n      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n    } else {\n      var nextAfterContinuation = null;\n      var node = firstCallbackNode;\n      do {\n        if (node.expirationTime >= expirationTime) {\n          // This callback expires at or after the continuation. We will insert\n          // the continuation *before* this callback.\n          nextAfterContinuation = node;\n          break;\n        }\n        node = node.next;\n      } while (node !== firstCallbackNode);\n\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority callback was found, which means the new\n        // callback is the lowest priority callback in the list.\n        nextAfterContinuation = firstCallbackNode;\n      } else if (nextAfterContinuation === firstCallbackNode) {\n        // The new callback is the highest priority callback in the list.\n        firstCallbackNode = continuationNode;\n        ensureHostCallbackIsScheduled();\n      }\n\n      var previous = nextAfterContinuation.previous;\n      previous.next = nextAfterContinuation.previous = continuationNode;\n      continuationNode.next = nextAfterContinuation;\n      continuationNode.previous = previous;\n    }\n  }\n}\n\nfunction flushImmediateWork() {\n  if (\n  // Confirm we've exited the outer most event handler\n  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n    isExecutingCallback = true;\n    deadlineObject.didTimeout = true;\n    try {\n      do {\n        flushFirstCallback();\n      } while (\n      // Keep flushing until there are no more immediate callbacks\n      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n    } finally {\n      isExecutingCallback = false;\n      if (firstCallbackNode !== null) {\n        // There's still work remaining. Request another callback.\n        ensureHostCallbackIsScheduled();\n      } else {\n        isHostCallbackScheduled = false;\n      }\n    }\n  }\n}\n\nfunction flushWork(didTimeout) {\n  isExecutingCallback = true;\n  deadlineObject.didTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the expired callbacks without yielding.\n      while (firstCallbackNode !== null) {\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.expirationTime <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime);\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n      }\n    }\n  } finally {\n    isExecutingCallback = false;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled();\n    } else {\n      isHostCallbackScheduled = false;\n    }\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    var previousEventStartTime = currentEventStartTime;\n    currentPriorityLevel = parentPriorityLevel;\n    currentEventStartTime = exports.unstable_now();\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n      currentEventStartTime = previousEventStartTime;\n      flushImmediateWork();\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(callback, deprecated_options) {\n  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n\n  var expirationTime;\n  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n    // FIXME: Remove this branch once we lift expiration times out of React.\n    expirationTime = startTime + deprecated_options.timeout;\n  } else {\n    switch (currentPriorityLevel) {\n      case ImmediatePriority:\n        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n        break;\n      case UserBlockingPriority:\n        expirationTime = startTime + USER_BLOCKING_PRIORITY;\n        break;\n      case IdlePriority:\n        expirationTime = startTime + IDLE_PRIORITY;\n        break;\n      case NormalPriority:\n      default:\n        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n    }\n  }\n\n  var newNode = {\n    callback: callback,\n    priorityLevel: currentPriorityLevel,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, ordered first by expiration, then\n  // by insertion. So the new callback is inserted any other callback with\n  // equal expiration.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled();\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.expirationTime > expirationTime) {\n        // The new callback expires before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later expiration was found, which means the new\n      // callback has the latest expiration in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest expiration in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled();\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_cancelCallback(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestHostCallback;\nvar cancelHostCallback;\nvar getFrameDeadline;\n\nif (typeof window !== 'undefined' && window._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var impl = window._schedMock;\n  requestHostCallback = impl[0];\n  cancelHostCallback = impl[1];\n  getFrameDeadline = impl[2];\n} else if (\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' ||\n// \"addEventListener\" might not be available on the window object\n// if this is a mocked \"window\" object. So we need to validate that too.\ntypeof window.addEventListener !== 'function') {\n  var _callback = null;\n  var _currentTime = -1;\n  var _flushCallback = function (didTimeout, ms) {\n    if (_callback !== null) {\n      var cb = _callback;\n      _callback = null;\n      try {\n        _currentTime = ms;\n        cb(didTimeout);\n      } finally {\n        _currentTime = -1;\n      }\n    }\n  };\n  requestHostCallback = function (cb, ms) {\n    if (_currentTime !== -1) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb, ms);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, ms, true, ms);\n      setTimeout(_flushCallback, maxSigned31BitInt, false, maxSigned31BitInt);\n    }\n  };\n  cancelHostCallback = function () {\n    _callback = null;\n  };\n  getFrameDeadline = function () {\n    return Infinity;\n  };\n  exports.unstable_now = function () {\n    return _currentTime === -1 ? 0 : _currentTime;\n  };\n} else {\n  if (typeof console !== 'undefined') {\n    // TODO: Remove fb.me link\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledHostCallback = null;\n  var isMessageEventScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isFlushingHostCallback = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  getFrameDeadline = function () {\n    return frameDeadline;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isMessageEventScheduled = false;\n\n    var prevScheduledCallback = scheduledHostCallback;\n    var prevTimeoutTime = timeoutTime;\n    scheduledHostCallback = null;\n    timeoutTime = -1;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        scheduledHostCallback = prevScheduledCallback;\n        timeoutTime = prevTimeoutTime;\n        return;\n      }\n    }\n\n    if (prevScheduledCallback !== null) {\n      isFlushingHostCallback = true;\n      try {\n        prevScheduledCallback(didTimeout);\n      } finally {\n        isFlushingHostCallback = false;\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    if (scheduledHostCallback !== null) {\n      // Eagerly schedule the next animation callback at the beginning of the\n      // frame. If the scheduler queue is not empty at the end of the frame, it\n      // will continue flushing inside that callback. If the queue *is* empty,\n      // then it will exit immediately. Posting the callback at the start of the\n      // frame ensures it's fired within the earliest possible frame. If we\n      // waited until the end of the frame to post the callback, we risk the\n      // browser skipping a frame and not firing the callback until the frame\n      // after that.\n      requestAnimationFrameWithTimeout(animationTick);\n    } else {\n      // No pending work. Exit.\n      isAnimationFrameScheduled = false;\n      return;\n    }\n\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If the calculated frame time gets lower than 8, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isMessageEventScheduled) {\n      isMessageEventScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  requestHostCallback = function (callback, absoluteTimeout) {\n    scheduledHostCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isFlushingHostCallback || absoluteTimeout < 0) {\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      window.postMessage(messageKey, '*');\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelHostCallback = function () {\n    scheduledHostCallback = null;\n    isMessageEventScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n  })();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}